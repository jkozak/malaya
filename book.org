#+TITLE: Malaya
#+AUTHOR: John Kozak

* Introduction
** Basics

Malaya is a logic-based relational data storage and processing system.

There's a class of applications which are about taking in data from a
variety of sources, weaving them together with past data and sending
appropriate data out.  They typically run forever and are often called
daemons or services.

Such applications include:
 - trading systems
 - messaging systems, client/server and distributed
 - instrumentation and control, e.g. IoT
 - CI systems, chat bots

Malaya is designed to make this easier.  It is a language and runtime
for the concise and rapid expression, implementation and deployment of
rule-based persistent reactive systems.  Data is everywhere JSON;
[[prevalence][persistent storage]] is based around a hash-chained journal of updates
which is tamper-proof and maintains the system's entire history; it is
thus eminently auditable.

It consists of:
 - [[JSON pattern matching]]
 - a [[Constraint Handler Rules][logic programming system]] based on [[https://en.wikipedia.org/wiki/Constraint_Handling_Rules][CHR]]
 - a persistence layer based on [[prevalence][prevalence]]
 - a [[CLI][runtime system]]
 - [[plugins][plugins]] to implement
  - timers
  - tcp and udp sockets
  - http, https
  - websockets
  - file I/O
  - slack, matrix, SSB, IRC, &c
  - ssh
  - stripe
  - email

** A foretaste - tiny DNS server

This is a [[https://en.wikipedia.org/wiki/Domain_Name_System#Recursive_and_caching_name_server][caching DNS server]]: it will answer dns queries from either
its cache or by consulting an upstream server.

#+begin_src malaya
module.exports.main = store {
    ['config',{}];
    ['counters',{dnsId:8888}];

    rule (-['query',   {id,flags:{opcode,...}, q,...},    {src:['udp',...addr]}],
           ['rr',      {q,rds,...}],
          +['response',{id,flags:{opcode,rc:0},q,
                        ans:rds.map(rdObj) },             {dst:['udp',...addr]}] );

    rule ( ['query',   {id,flags:{opcode,...}, q,...},    {src:['udp',...addr]}],
           ['config',  {dnsUpstream,...}],
          +['query',   {id,flags:{opcode,ra:1},q},        {dst:['udp',...dnsUpstream]}] );

    rule (-['response',{id,flags:{opcode,...}, q,ans,...},{src:['udp',...dnsUpstream]}],
           ttd = ans.length>0 ? ans[0].ttl*1000+Date.now() : 60000,
          +['rr',      {q,rds:ans.map(function(an){return an.rd;}),ttd}] );

    rule ( ['rr',{q,...}],      // only one RR record per name/class/type, poss with multiple rd
          -['rr',{q,...}] );

    rule ( ['tick',{t,...},{src:'timer'}],
          -['rr',{ttd,...}],
           t>=ttd );

    rule (-['tick',{...},{src:'timer'}])

    rule (-['restart',{dnsUpstream,...config},{src:'restart'}],
           dnsU = (typeof dnsUpstream=='string') ? [dnsUpstream,53] : dnsUpstream,
          +['configChange',{dnsUpstream:dnsU,...config}] );

    rule (-['configChange',{...config1}],
          -['config',{...config0}],
          +['config',Object.assign({},config0,config1)] );
}
    .plugin('restart',{dnsUpstream:['8.8.8.8',53]})
    .plugin('timer',{interval:10000})
    .plugin('fifo',{path:'control'})
    .plugin('udp',{
        port:    53,
        encoder: {
            pack:   packDNS,
            unpack: unpackDNS
        }
    });
#+end_src

Code for unpacking and packing JSON into binary format has been
omitted for brevity.  Complete code can be found in the distribution
as [[file:./examples/dns.malaya][examples/dns.malaya]].

If you know DNS, this might make some sense, and you'll spot that
there are some errors and omissions which we'll deal with when we
revisit this at greater length [[DNS example][below]].  It is usable as-is, though.

Run it like this (assuming [[Installation][source distribution]] at =~/malaya=):
#+begin_example
~/malaya$ ./malaya -O udp.port=10053 exec -D examples/dns.malaya
#+end_example

And will answer queries (you'll need [[https://en.wikipedia.org/wiki/Dig_(command)][=dig=]], obviously):
#+begin_example
~$ dig -p10053 @localhost example.com
#+end_example

** Prerequisites
Malaya requires =nodejs=, and should run on any platform =nodejs= supports.

It is developed on linux, and (will be) tested on current versions of =nodejs=
on linux, windows and macOS.

* Installation

** General instructions
Install =nodejs= and =npm=; see [[https://nodejs.org/][the main =nodejs= site]] if in doubt
about this.

To install Malaya with a bundle of plugins, examples and
documentation, clone the source code repository and run =npm install=:
#+begin_example
~$ git clone https://github.com/jkozak/malaya
~$ cd malaya
~/malaya$ npm install
#+end_example

A more minimal installation can be had via =npm=:
#+begin_example
~$ npm install -g malaya
#+end_example
Note that some plugins are distributed as separate npm modules.

* JSON pattern matching
* Constraint Handler Rules
* Malaya fact stores
* Other language features
* Example 1 - turing machine
* Prevalence
<<prevalence>>
* The =malaya= command
<<CLI>>
** =cat=
** =exec=
** =fsck=
** =init=
** =kill=
** =run=
** =save=
** =status=
** =query=
* Engines - running the system
* Plugins - talking to the world
<<plugins>>
** introduction

A malaya system communicates with the outside world via plugins

# example

Plugins are attached to stores and can receive and send facts between
them.  A fact sent by a plugin instance called =garden= might look like this:

#BEGIN_SRC malaya
['bloom',{plant:'crocus'},{src:'garden'}]
#END_SRC

The =src= item identifies the plugin sending the fact.

Malaya code can send to the plugin like this:

#BEGIN_SRC malaya
['re-pot',{plant:'crocus'},{dst:'garden'}]
#END_SRC

Here the =dst= item identifies to which plugin instance the fact is to
be sent.  Effectively, the plugin adds an extra rule at the end of the
store to consume anything with a =dst= field in its third slot
matching its instance name.

** bundled plugins
*** =tcp=
*** =ws=
*** =udp=
*** =process=
*** =http=
*** =file=
*** =unix=
** other plugins
*** =bpf=
*** =dbus=
*** =email=
*** =inotify=
*** =LDAP=
*** =matrix=
*** =slack=
*** =ssb=
*** =ssh=
*** =stripe=
*** =syslog=
*** =systemd=
*** Cloud provider APIs, e.g. AWS, GCloud, Azure
*** eBPF

* Example 2 DNS
<<DNS example>>
* Example 3
* Updating the schema
* Example 4 - going international with multi-currency support
* Working with the journal
* Example 5 - GDPR
* Example 6 - installing a malaya server under linux
* Future directions

** compile to SQL
** GUI visualisation
** in-browser
** performance

*** better compilation
*** parallelisation
*** join tuning

*** autoindexing

** formal methods

*** model checking

** consensus (ePaxos?)
** p2p apps
** embed in other platforms than node
** (auto-)sharding
** operate on untranslated binary data

Avoid cost of binary->JSON->binary translation by compiling the
rules to work on binary data directly.

* Language reference
