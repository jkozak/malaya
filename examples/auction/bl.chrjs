module.exports =  store {

    rule (-['logon',{name,pw},{port}],
          -['user',{name,pw,enabled:true,port:null,...}],
          +['user',{name,pw,enabled:true,port}],
          +['_output','self',['logon',{ok:true}]] );
    rule (-['logon',{name,pw},...],
           ['user',{name,pw,enabled:false,port:null,...}],
          +['_output','self',['logon',{ok:false,msg:"logon disabled"}]] );
    rule (-['logon',{name,pw},...],
           ['user',{name,pw,enabled:true,port,...}],
           port!==null,
          +['_output','self',['logon',{ok:false,msg:"already logged on"}]] );
    rule (-['logon',{name,pw},...],
           ['user',{name,...}],
          +['_output','self',['logon',{ok:false,msg:"bad pw"}]] );
    rule (-['logon',{name,pw},...],
          +['_output','self',['logon',{ok:false,msg:"unknown user"}]] );
    rule ( ['logoff',{...},{port}],
          -['subscription',{port,...}] );
    rule (-['logoff',{...},{port}],
          -['user',{port,...rs}],
          +['user',{...rs,port:null}] );
    rule (-['logoff',...]);

    rule (-['lsAuctions',{...},{port}],
           ['user',{port,name}],
          +['_output','self',['subclasses',for ([];
                                                ['subclass',s];
                                                x=>[...x,s] )]],
          +['_output','self',['stocks',for ([];
                                            ['stock',s];
                                            x=>[...x,s] )]],
          +['_output','self',['auctions',for ([];
                                              ['auction',a];
                                              x=>[...x,a] )]],
          +['_output','self',['trades',for ([];
                                            ['trade',t];
                                            x=>([t.buyer,t.seller].indexOf(name)===-1 ? x : [...x,t]) )]] );


    rule (-['subclass',{name,...rs},{port}], // maintain subclasses
          -['subclass',{name,...}],
          +['subclass',{...rs,name}]);
    rule (-['stock',{name,...rs},{port}],    // maintain stocks
          -['stock',{name,...}],
          +['stock',{...rs,name}]);

    rule (-['auction',{id,state:'run',...rs1},{port}], // start auction, set start time
          -['auction',{id,state:ostate,...rs0}],
           (['new','ready'].indexOf(ostate)!==-1),
           ['user',{port,name,...}],
          +['auction',{owner:name,...rs0,...rs1,id:id,state:'run',start:Date.now()}] );
    rule (-['auction',{id,...rs1},{port}],             // update
          -['auction',{id,...rs0}],
           ['user',{port,name,...}],
          +['auction',{owner:name,...rs0,...rs1,id:id}] );
    rule (-['auction',{id,...},{port}],                // ensure sane
           console.log("no user found for %j",port) );

    rule ( ['_tick',{date,...},...],
           ['auction',{id,state:'run',start,duration,...rs}],
           rem = start+duration*1000-date,
           rem>0,
          +['_output','all',['tick',{id,remaining:rem/1000}]] );
    rule ( ['_tick',{date,...},...],
          -['auction',{state:'run',start,duration,...rs}],
           remaining = start+duration*1000-date,
           remaining<=0,
           +['auction',{...rs,state:'ended',start,duration}] );

    rule (-['price',{auction,stock,rate,buy,...rs},{port}], // set user name from port
           ['user',{name,port,...}],
          +['price',{...rs,auction,stock,rate,buy,user:name}] );

    rule (-['price',{volume:0,...rs},...],
          +['_output','all',['price',{volume:0,...rs}]] );
    rule ( ['price',{auction,stock,rate,buy,user,...}],     // new prices replace old
          -['price',{auction,stock,rate,buy,user,...}] );

    rule (-['price',{auction,stock,rate,volume:vB,user:uB,buy:true, ...brs}],
          -['price',{auction,stock,rate,volume:vS,user:uS,buy:false,...srs}],
           ['auction',{id:auction,type:'match'}],
           uB!==uS,
           vT=Math.min(vB,vS),
          +['price',{...brs,auction,stock,rate,volume:vB-vT,user:uB,buy:true}],
          +['price',{...srs,auction,stock,rate,volume:vS-vT,user:uS,buy:false}],
          +['trade',{auction,stock,rate,volume:vT,buyer:uB,seller:uS}] );

    // +++  dutch  +++
    // +++ english +++
    // +++ candle  +++

    // auctions determined at end

    rule ( ['auction',{id:auct,state:'ended',type:'blind',...}],
           ['price',{auction:auct,stock,buy:false,...brs}],
          +['trade',{auction:auct,stock,rate:0}] );
    rule ( ['auction',{id:auct,state:'ended',type:'blind',...}],
           ['price',{auction:auct,buy:false,user:uS,...brs}],
           ['price',{auction:auct,buy:true,user:uB,rate:pr,...srs}],
          -['trade',{auction:auct,rate:tr,...}],
           pr>tr,
          +['trade',{auction:auct,rate:pr,buyer:uB,seller:uS}] );

    // +++ vickrey - 2nd price sealed bid +++

    rule (-['cloneAuction',{id,...rs},{port}],      // create a new auction from an old one
           ['auction',{id,...ars}],
          -['counters',{auction,...crs}],
           ['user',{port,name,...}],
          +['counters',{...crs,auction:auction+1}],
          +['auction',{...ars,...rs,base:id,state:'new',id:'a#'+auction,owner:name}] );

    rule (-['auction',{state:'new',...ars},{port}], // create a new auction
          -['counters',{auction,...crs}],
           ['user',{port,name,...}],
          +['counters',{...crs,auction:auction+1}],
          +['auction',{...ars,state:'new',id:'a#'+auction,owner:name}] );

          rule (-['auction',{...rs,state:'ended'}],
                +['auction',{...rs,state:'done'}] );

          rule ( ['auction',{...rs,state}], // send most auction updates out
           state!=='new',
                 +['_output','all',['auction',{...rs,state}]] );
          rule ( ['auction',{...rs,state}], // send new auction updates out to author only
           state==='new',
                 +['_output','self',['auction',{...rs,state}]] );
    rule ( ['price',rs],              // send all price updates out
          +['_output','all',['price',rs]] );
    rule ( ['trade',rs],              // send all price updates out
          +['_output','all',['trade',rs]] );
    rule ( ['stock',rs],              // send all stock updates out
          +['_output','all',['stock',rs]] );
    rule ( ['subclass',rs],           // send all subclass updates out
          +['_output','all',['subclass',rs]] );

    // admin

    rule ( ['lsUsers',{subscribe:true},{port}],
          +['subscription',{what:'user',port}] );
    rule ( ['lsUsers',{subscribe:false},{port}],
          -['subscription',{what:'user',port}] );
    rule (-['lsUsers',{...},{...}],
          +['_output','self',['users',for ([];
                                           ['user',u];
                                           x=>x.concat(u) )]] ); // !!! omit password !!!
    rule ( ['user',{pw,...rs}], // send all user updates out
           ['subscription',{what:'user',port}],
          +['_output',port,['user',rs]] );

    // standard housekeeping

    rule ( ['_take-outputs',...], -['_output',...]);
    rule (-['_take-outputs',...]);

    rule ( ['_restart',...],
          -['user',{loggedOn:true,...rs}],
           +['user',{...rs,loggedOn:false}] );
    rule ( ['_restart',...],
          -['subscription',...] );
    rule ( ['_restart',...],
          -['_output',...] );
    rule (-['_restart',...]);
    rule (-['_tick',...]);

};

// ['auction',{id,type,state:'ready'|'run'|'pause'|'ended'|'done',start,duration,stocks,prices,trades}]
// may be extra states for wacky auctions
// can chain auctions together with `next:<id>` (e.g. stage1->secondChance)
// `type` will correspond to a block of rules
