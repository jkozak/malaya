function unpackDNSname(buf,off) {
    const ans = [];
    while (true) {
        var n = buf.readUInt8(off);
        if (n===0)
            return [ans,off+1];
        ans.push(buf.slice(off+1,off+n+1).toString('ascii'));
        off += n+1;
    }
}

function packDNSname(buf,off,v) {
    v.forEach(function(n){
        buf.writeUInt8(n.length,off++);
        for (var i=0;i<n.length;i++)
            buf.writeUInt8(n.charCodeAt(i),off++);
    });
    buf.writeUInt8(0,off++);
    return off;
}

function packDNS(js) {
    let   off = 0;
    const buf = Buffer.alloc(50);
    off = buf.writeUInt16BE(js.id,off);
    off = buf.writeUInt16BE(((js.flags.qr     || 0) << 15) +
                            ((js.flags.opcode || 0) << 14) +
                            ((js.flags.aa     || 0) << 11) +
                            ((js.flags.tc     || 0) << 10) +
                            ((js.flags.rd     || 0) << 9)  +
                            ((js.flags.ra     || 0) << 8)  +
                            ((js.flags.rc     || 0)),
                            off);
    off = buf.writeUInt16BE(js.qdcount||0,off);
    off = buf.writeUInt16BE(js.ancount||0,off);
    off = buf.writeUInt16BE(js.nscount||0,off);
    off = buf.writeUInt16BE(js.arcount||0,off);
    off = packDNSname(buf,off,js.qname);
    off = buf.writeUInt16BE(js.qtype||0,off);
    off = buf.writeUInt16BE(js.qclass||0,off);
    if (js.name) {
        off = packDNSname(buf,off,js.name);
        off = buf.writeUInt16BE(js.type  || js.qtype, off);
        off = buf.writeUInt16BE(js.clasz || js.qclass,off);
        off = buf.writeUInt32BE(js.ttl || 0,          off);
        switch (js.type) {
        case 1:
            off = buf.writeUInt16BE(4,off);
            off = buf.writeUInt32BE(0x02020202,off); // !!!
            break;
        default:
            console.log("bad type: %j",js.type);
            break;
        }
    }
    return buf.slice(0,off);
}

function unpackDNS(buf) {
    const   pdn = unpackDNSname(buf,12);
    const flags = buf.readUInt16BE(2);
    return {
        id:      buf.readUInt16BE(0),
        flags:   {
            qr:     (flags >> 15) & 0x01,
            opcode: (flags >> 14) & 0x0F,
            aa:     (flags >> 11) & 0x01,   // not for query
            tc:     (flags >> 10) & 0x01,
            rd:     (flags >>  9) & 0x01,
            ra:     (flags >>  8) & 0x01,   // not for query
            rc:     (flags      ) & 0x0F    // not for query
        },
        qdcount: buf.readUInt16BE(4),
        ancount: buf.readUInt16BE(6),
        nscount: buf.readUInt16BE(8),
        arcount: buf.readUInt16BE(10),
        qname:   pdn[0],
        qtype:   buf.readUInt16BE(pdn[1]),
        qclass:  buf.readUInt16BE(pdn[1]+2)
    };
}

module.exports.main = store {
    rule (-['data',
            {id,flags:{qr:0,opcode,...}, qname,qtype,qclass,...},
            {src:['udp',...addr]}],
          +['data',
            {id,flags:{qr:1,opcode,rc:0},qname,qtype,qclass,
             qdcount:1,ancount:1,
             name:qname,clasz:qclass,type:qtype},
            {dst:['udp',...addr]}] );

}
    .plugin('udp',{
        port:    53,
        encoder: {
            pack:   packDNS,
            unpack: unpackDNS
        }
    });

module.exports._private = {
    packDNSname:   packDNSname,
    unpackDNSname: unpackDNSname,
    packDNS:       packDNS,
    unpackDNS:     unpackDNS
};
