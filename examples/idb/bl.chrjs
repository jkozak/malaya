var     _ = require('underscore');
var    fs = require('fs');
var faker = require('faker');

function dateToYYYYMMDD(md) {
    var d = new Date(md).toISOString();
    return d.substr(0,4)+d.substr(5,2)+d.substr(8,2);
}

function mkHeartbeat(d) {
    // want a heartbeat only every two seconds
    if (d.getSeconds()%2===1)
	return null;
    else
	return {heartbeat:{timestamp:d.toTimeString().substring(0,9)+d.getDate()+'/'+(d.getMonth()+1)+'/'+(d.getYear()+1900)}};
}

function addToPropertyList(obj,prop,value) {
    if (obj[prop]===undefined)
	obj[prop] = [];
    obj[prop].push(value);
    return obj;
}
function addToIndexList(obj,prop,value) {
    obj[prop] = value;
    return obj;
}

// need to handle these messages:
//  X AuctionTemplateBlock
//    AuctionTemplate
//    AuctionDelAll
//    PrepareAuction
//    StartPreparedAuction
//    AuctionSecondChance
//    AuctionMatch
//  X start
//  X cookie
//  X store-cookie
//  X logon
//    price
//    trade
//  X market-status
//    InstHightlight
//    BigFigBlock
//    EndBigFigBlock
//    AuctionPriceBlock

var IDB = store {
    // filter the db data on its way in to remove the more egregious nasties
    // +++ this should be a transform +++
    rule (-['Permissions',{Password,...rs}],                              // remove trailing pwd spaces
	  Password && Password.charAt(Password.length-1)===' ',
	  +['Permissions',{Password:Password.trimRight(),...rs}]);
    rule (-['Permissions',{ApplicationName:"John Kozak",Password,...rs}], // tweak my pwd
	  Password!=="JK",
	  +['Permissions',{ApplicationName:"John Kozak",Password:"JK",...rs}]);
    rule (-['Permissions',{ApplicationName,Password,...rs}],              // anonymise users and passwords
	  ApplicationName!=="John Kozak" && !rs.hasOwnProperty('anon'),
	  aname = faker.name.findName(),
	  apwd  = faker.internet.password(),
	  +['Permissions',{ApplicationName:aname,Password:apwd,anon:null,...rs}]);

    // the market itself
    rule (['MarketManager',{MarketID}],  -['MarketManager',{MarketID}]);
    rule (-['market-status',{ID,status}],
	  -['MarketManager',{MarketID:ID,Status,...rs}],
	  +['MarketManager',{MarketID:ID,Status:status,...rs}]);

    // restart
    rule (['restart'],
	  -['Permissions',{LoggedOn:1,...rs}],
	  +['Permissions',{LoggedOn:0,...rs}] );
    rule (['restart'], -['_output']);
    rule (['restart'], -['_take-outputs']);
    rule (['restart'], -['tick']);
    rule (['restart'], -['restart']); // shouldn't happen, but if a bad world is saved...
    rule (-['restart']);
    
    // logon processing
    rule (-['logon',      {user,pw},{port}],
	  -['Permissions',{ApplicationName:user,Password:pw,LoggedOn:0,...rs}],
	  +['Permissions',{ApplicationName:user,Password,LoggedOn:1,port,...rs}],
	  +['_output','self',{logon:{OK:1,session_key:0}}]
	 );
    rule (-['logon',      {user,pw}],
	  ['Permissions',{ApplicationName:user,Password:pw,LoggedOn:1}],
	  +['_output','self',{error:{_children:{code:16,text:"already logged on"}}}] );
    rule (-['logon',      {user}],
	  ['Permissions',{ApplicationName:user}],
	  +['_output','self',{error:{_children:{code:17,text:"bad password"}}}] );
    rule (-['logon'],
	  +['_output','self',{error:{_children:{code:18,text:"user unknown"}}}] );
    rule (['Permissions',{ApplicationID}],
	  -['Permissions',{ApplicationID}]);
    rule (-['logoff',     {appId}],
	  -['Permissions',{ApplicationID:appId,LoggedOn:1,port,...rs}],
	  +['Permissions',{ApplicationID:appId,LoggedOn:0,port:null,...rs}] );

    // cookies
    rule (-['store-cookie',{id,cookie},{port}],
	  ['Permissions',{port,ApplicationID}],
	  -['Cookies',{ApplicationID,CookieID:id,Cookie:cookie}],
	  +['Cookies',{ApplicationID,CookieID:id,Cookie:cookie}] );

    // background
    rule (['tick',{date}],
	  +['_output','all',mkHeartbeat(date)] );
    rule (-['tick']);

    // output
    rule (['_take-outputs'], -['_output']);
    rule (-['_take-outputs']);


    query users(;
		['Permissions',{ApplicationID,ApplicationName,Password}];
		a=[])  a.concat([[ApplicationID,ApplicationName,Password]]);
    query user(appId;
	       ['Permissions',{ApplicationID:appId,...rs}];
	       a=[])  a.concat([rs]);

    query staticdata(;
		     ['Permissions',{ApplicationID:appId,TeamID:teamId,CompanyID:companyId}],
		     ['Team',{TeamID:teamId,TeamName:team}];
		     a=[]) a.concat([{app:appId,team:teamId,Name:team}]);

    query instruments(appId;	// +++ make per-user
		      ['Instrument',inst];
		      a=[]) a.concat([{
			  ID:               inst.InstID,
			  Name:             inst.InstName,
			  SubClass:         inst.InstSubClassID,
			  Maturity:         dateToYYYYMMDD(inst.MaturityDate),
			  'new':            0,
			  Visible:          inst.VisibleFlag,
			  Description:      inst.InstDesc,
			  AuctionInstTitle: inst.AuctionInstTitle,
			  PriceTick:        inst.PriceTick
		      }]);

    query feCookies(;
		    ['FEConfig',{TabID,CookieData}];
		    a=[]) a.concat(CookieData);

    query subclasses(appId;	// +++ make per-user
		     ['InstrumentClass',sc];
		     a=[]) a.concat([{
			 ID:                sc.InstSubClassID,
			 Name:              sc.InstSubClassName,
			 AssociatedTitleID: sc.AssociatedTitle,
			 Title:             sc.Title,
			 DefltVol:          sc.DefaultVolume,
			 PriceTick:         sc.PriceTick,
			 ShowSign:          sc.Display_ShowPlusMinus,
			 xBidMinus1:        sc.Match_xBidMinus1,
			 AuctionVolumes:    sc.AuctionVolumes
		     }]);

    query cookie(appId,id;
		 ['Cookies',{ApplicationID:appId,CookieID:id,Cookie}];
		 a=[]) a.concat(Cookie);

    query markets(id;
		  ['MarketManager',{MarketID:id,Status}],
		  ['SequenceNumbers',{MarketID,PriceSequenceNo,TradeSequenceNo}];
		  a=[]) a.concat({ID:        id,
		                  status:    Status,
				  priceSeqNo:PriceSequenceNo,
				  tradeSeqNo:TradeSequenceNo});
    query prices(id;
		 ['Price',{Action,Status,...rs}],
		 ("UC").indexOf(Action)!==-1 && ("RATS").indexOf(Status)!==-1;
		 // +++ above tests not complete +++
		 a=[]) a.concat({ID:        rs.PriceID,
				 seqNo:     rs.PriceSequenceNo,
				 isBuy:     rs.BidOrOffer,
				 instrument:rs.InstID,
				 x:         rs.Rate,
				 volume:    rs.Amount,
				 action:    Action,
				 status:    Status,
				 valueDate: rs.ValuationDate,
				 minLotSize:rs.MinLotSize});

    // +++ query trades(id; +++

    query auctionTemplates(;
			   ['AuctionTemplate',at];
			   a=[]) a.concat([{
			       cls:                  1,
			       name:                 at.AuctionName,
			       id:                   at.AuctionTemplateID,
			       instance:             0,
			       phases:               at.AuctionPhases,
			       duration:             at.AuctionDuration,
			       MatchingDuration:     at.MatchingDuration,
			       SecondChanceDuration: 0
			   }]);
    query auctionTemplate(id;
			  ['AuctionTemplate',{AuctionTemplateID:id,...at}];
			  a=[]) {
			      cls:                  1,
			      name:                 at.AuctionName,
			      id:                   id,
			      instance:             0,
			      phases:               at.AuctionPhases,
			      duration:             at.AuctionDuration,
			      MatchingDuration:     at.MatchingDuration,
			      SecondChanceDuration: 0
			   };
    query auctionTemplateInstances(id;
				   ['AuctionInstrumentsTemplate',{AuctionTemplateID:id,InstID,...ait}],
				   ['Instrument',{InstID,...inst}];
				   a=[]) a.addToIndexList(ait.AuctionTemplateInstance,{
				       InstID:       InstID,
				       Midprice:     inst.MidPrice,
				       Tolerance:    inst.VolatilityPercent,
				       AddTolerance: inst.VolatilitySpread
				   });
    // +++ templates -> template,... -> instance,... -> instrument,... +++
};

module.exports = IDB;

